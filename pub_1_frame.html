<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 20010904//EN"              "https://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<html lang="en">
<head>

  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <!-- Custom styles for this template -->
  <link href="css/grayscale.min.css" rel="stylesheet">
  <link href="css/pub_1_frame.min.css" rel="stylesheet">

  <!-- Custom fonts for this template -->
  <link href="vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Cabin:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet" type="text/css" >

  <!-- Override bootstrap and custom styles for just this page -->
  <style>
    .container-canvas {
      margin: 10 0 auto;
      width: 100%;
    }
  </style>
</head>
  <body>
    <!-- Canvas where the drawing happens -->
    <div class="container" align="center" width="100%" height="500px" padding-top="20px">
      <!-- <div class="container-canvas"> -->
        <!-- <canvas id="canvas" width="300" height="500"></canvas> -->
        <!-- <img src="img/drawing.svg"></img>
        <img src="img/drawing-1.svg"></img> -->
        <!-- first path is right, second is left, third is middle -->
        <svg id="model-thread" xmlns="https://www.w3.org/2000/svg" align="center" width="400px" height="400px" viewBox="0 0 400 400">

          <text visibility="hidden" x="5" y="15" font-family="Ubuntu" font-size="12" fill="white" style="animation-delay:3s">
            time
          </text>

          <!-- time line -->
          <path class="path"id="draw-time" fill="none" stroke-width="3" style="stroke:blue; animation-delay:4s; marker-end:url(#arrow-time);"
          d="M 0,0 V 300" />
          <path class="dashed" id="draw-time-black" fill="none" stroke-width="3" style="stroke:black; animation-delay:4s;"
          d="M 0,0 V 300" />

          <!-- initial process -->
          <path id="draw-10" fill="none" stroke="green" stroke-width="3" style="animation-delay:4s;"
          d="M 100,0 V 50" />

          <text visibility="hidden" x="105" y="10" font-family="Ubuntu" font-size="12" fill="white" style="animation-delay:4s">
            P1
          </text>

          <text visibility="hidden" x="105" y="50" font-family="Ubuntu" font-size="12" fill="white" style="animation-delay:6s">
            thread()
          </text>

          <!-- split right -->
          <path id="right-1" fill="none" stroke="green" stroke-width="3" style="animation-delay:6s;"
          d="M 100,50 L 150,100" />

          <text visibility="hidden" x="155" y="100" font-family="Ubuntu" font-size="12" fill="white" style="animation-delay:8s">
            T3
          </text>

          <!-- split left -->
          <path id="left-1" fill="none" stroke="green" stroke-width="3" style="animation-delay:6s;"
          d="M 100,50 L 50,100" />

          <text visibility="hidden" x="55" y="100" font-family="Ubuntu" font-size="12" fill="white" style="animation-delay:8s">
            T2
          </text>

          <!-- middle -->
          <path id="mid-1" fill="none" stroke="green" stroke-width="3" style="animation-delay:5.5s;"
          d="M 100,50 L 100,100" />

          <text visibility="hidden" x="105" y="100" font-family="Ubuntu" font-size="12" fill="white" style="animation-delay:6s">
            T1
          </text>

          <!-- marker for division -->
          <circle visibility="hidden" cx="100" cy="50" r="5" style="stroke: black; fill: red; animation-delay:5s"/>

          <!-- right straight down -->
          <path id="right-2" fill="none" stroke="green" stroke-width="3" style="animation-delay:8s;"
          d="M 150,100 L 150,200" />

          <!-- left straight down -->
          <path id="left-2" fill="none" stroke="green" stroke-width="3" style="animation-delay:8s;"
          d="M 50,100 L 50,200" />

          <!-- middle down again -->
          <path id="mid-2" fill="none" stroke="green" stroke-width="3" style="animation-delay:8s;"
          d="M 100,100 L 100,200" />

          <!-- right join to mid -->
          <path id="right-3" fill="none" stroke="green" stroke-width="3" style="animation-delay:10s;"
          d="M 150,200 L 100,250" />

          <!-- left join to mid -->
          <path id="left-3" fill="none" stroke="green" stroke-width="3" style="animation-delay:10s;"
          d="M 50,200 L 100,250" />

          <!-- mid join with others -->
          <path id="mid-3" fill="none" stroke="green" stroke-width="3" style="animation-delay:10s;"
          d="M 100,200 L 100,250" />

          <text visibility="hidden" x="105" y="250" font-family="Ubuntu" font-size="12" fill="white" style="animation-delay:11s">
            join()
          </text>

          <!-- all three down together -->
          <path id="draw-12" fill="none" stroke="green" stroke-width="3" style="animation-delay:12s;"
          d="M 100,250 L 100,300" />

          <!-- marker for connection -->
          <circle visibility="hidden" cx="100" cy="250" r="5" style="stroke: black; fill: red; animation-delay:12s"/>

          <text visibility="hidden" x="105" y="300" font-family="Ubuntu" font-size="12" fill="white" style="animation-delay:14s">
            P1
          </text>

        </svg>
      <!-- </div> -->
       <button class="btn" onclick="restartThreadAnimation()" style="margin:15px;">Restart</button>
    </div>

    <div class="container">
      <div>
        <br>
        <h3>Model 1. Threaded.</h3>
        <p class="item-intro" style="font-family: Ubuntu; font-size:18; color:green">
        The multi-threaded APU at work in the human...
        </p>
        <br>
        <p>The initial line (P1) represents the user's main thought process.  At that point, there is only one process running.  The user could be in a state of deep attention toward one thing.  For example, the user focuses on reading a dense academic journal.  Then, two more processes start in the background to deal with 'distractions', such as a phone vibrating upon receipt of a text message.  The phone demands attention.  The main process is then split into three: the <span style="color:green;">first</span> branch of attention continues to focus on the academic journal, the <span style="color:green;">second</span> attends to the phone's now-lit screen, and the <span style="color:green;">third</span> is a realization of the distraction and the work required to either respond to the message or redirect one's attention back toward the academic journal.  The divergence of the main line into three separate paths represents this split.  For the APU, this requires multi-threading.  Each process has access to the same underlying system resources, and each process has a specific start point founded in the original process.  They perform their own operations, sometimes modifying the same underlying data.  When two threads mutate the same object, the program may err.  It cannot trust the integrity of its output because two different functions use and modify the same resources for different purposes.  As the processes conclude, the APU must join them together, which is an arduous task for the APU if it also needs to understand how the processes interacted with the system data while they were on their respective paths.  The speed and correctness of the joining phase depends on how well each thread isolated and shared its data.  After the joining function succeeds, the processor returns to a <span style="color:green;">solitary thread</span>, a state of deep attention on one item.  The deep attention toward the academic journal resumes.
        </p>
        <p>This progression--and its problems--mimics that of parallel computing.  When threads in a multi-threaded program access the same system data, they must obtain a `lock` on the data before operating on it.  This mechanism prevents other threads from altering the data while the live thread acts.  There are several different ways to implement data locking.  Some are very fast, and some are very slow in different use cases.
        </p>
        <br>
        <br>
        <h3>Model 2. Forked.</h3>
        <p class="item-intro" style="font-family: Ubuntu; font-size:18; color: green;">
        The forked APU at work in the human...
        </p>
        <div class="container" align="center" width="100%" height="500px" padding-top="20px">
          <svg id="model-fork" xmlns="https://www.w3.org/2000/svg" align="center" width="400px" height="400px" viewBox="0 0 400 400">

            <defs>
              <marker id="arrow-time" markerWidth="10" markerHeight="10" refX="0" refY="0" orient="auto" markerUnits="strokeWidth">
                <path d="M0,0 L0,4 L7,2 z" style="stroke:blue" />
              </marker>
            </defs>

            <text visibility="hidden" x="5" y="15" font-family="Ubuntu" font-size="12" fill="white" style="animation-delay:15s">
              time
            </text>

            <!-- time line -->
            <path class="path"id="draw-time" fill="none" stroke-width="3" style="stroke:blue; animation-delay:16s; marker-end:url(#arrow-time);"
            d="M 0,0 V 300" />
            <path class="dashed" id="draw-time-black" fill="none" stroke-width="3" style="stroke:black; animation-delay:16s;"
            d="M 0,0 V 300" />

            <!-- p1 -->
            <text visibility="hidden" x="55" y="10" font-family="Ubuntu" font-size="12" fill="white" style="animation-delay:16s">
              P1
            </text>

            <path id="draw-2" fill="none" stroke="green" stroke-width="3" style="animation-delay:16s;"
            d="M 50,0 V 100" />
            <circle visibility="hidden" cx="50" cy="100" r="5" style="stroke: black; fill: red; animation-delay:18s"/>

            <text visibility="hidden" x="55" y="100" font-family="Ubuntu" font-size="12" fill="white" style="animation-delay:18.5s">
              fork()
            </text>

            <!-- p2 -->
            <text visibility="hidden" x="155" y="100" font-family="Ubuntu" font-size="12" fill="white" style="animation-delay:19s">
              P2
            </text>

            <path id="draw-3" fill="none" stroke="green" stroke-width="3" style="animation-delay:19s;"
            d="M 150,100 V 200" />
            <circle visibility="hidden" cx="150" cy="200" r="5" style="stroke: black; fill: red; animation-delay:21s" />

            <text visibility="hidden" x="155" y="200" font-family="Ubuntu" font-size="12" fill="white" style="animation-delay:21.5s">
              fork()
            </text>

            <!-- p3 -->
            <text visibility="hidden" x="255" y="200" font-family="Ubuntu" font-size="12" fill="white" style="animation-delay:22s">
              P3
            </text>

            <path id="draw-4" fill="none" stroke="green" stroke-width="3" style="animation-delay:22s;"
            d="M 250,200 V 300" />
            <circle visibility="hidden" cx="250" cy="300" r="5" style="stroke: black; fill: red; animation-delay:24s" />

            <!-- join with P2 and P1 -->
            <!-- <text visibility="hidden" x="255" y="300" font-family="Ubuntu" font-size="12" fill="white" style="animation-delay:24.5s">

            </text> -->
          </svg>
        <!-- </div> -->
         <button class="btn" onclick="restartForkAnimation()" style="margin:15px;">Restart</button>
        </div>
        <br>
        <p>Again, the initial line represents the user's main thought process with one process running.  The user focuses on the academic journal.  When the user's phone vibrates and a 'distraction' arises that requires the user's attention, the main process of reading pauses and runs in the background while the user attends to the notification.  In this sense, the process forks to attend to the 'distraction'.  The forked process spawns an entirely new process.  It does not share the same resources as the original process.  It runs as if it were the only thing on the user's mind.  The pattern repeats when another distracting process begins: in this case, the distraction from the distraction, in which the user takes note of his lack of focus.  All other processes run in the background, but without conducting any activity.  When a forked process concludes, control of system resources is handed back to the previous process.  The APU must manage the processes' scheduling and resources.</p>
        <p>This forking process is also implemented in computer operating systems.  It differs from multi-threading in that it always isolates system resources for each process.  Each process acts as its own program.  Instead of splitting into multiple branches as is the case with the threading, calling <code>fork()</code> gives birth to an independent program.  The new program executes and then returns to the parent process.  Because modern computers have several processing units, they can run forked programs at the same time, similar to the parallel nature of multi-threading.  However, spawning large numbers of forked processes is time-consuming because the computer needs to create copies of the program for each new process.  If the programmer needs to perform numerous independent actions at once, it is therefore advisable to implement threading.
        </p>
        <br>
        <p>In each case, attention is a mechanism.  It is not a commodity or resource.  On the contrary, it manages other resources.</p>
        <p>This concept is--in some ways--modeled off of Herbert Simon's discussion of the information-processing system (IPS).  He describes a computer's primary functionalities as input, storage and memory, computing, and output.  For Simon, "the distribution of [a computer's] own attention" among those same features determine how useful computers are to combatting information overload.  He argues that attention is a resource that acts on information.  The computer's purpose is to reduce information so that humans manage their own attention resources better.  However, it is reasonable to depart from this object-oriented ideology.  Considering attention as the function rather than the resource clarifies its role.  It manages how computers and humans interact with information, not the other way around.
        </p>
        <p>The threaded APU model aligns with Hayles's model of hyper attention.  Threading is a powerful computing option when a large number of independent and smaller tasks can be executed at the same time.  For example, it is useful for cracking passwords.  Passwords are often stored as hashes, which are seemingly random strings of characters generated by an algorithm that is very difficult to reverse.  The only way to efficiently guess the password that corresponds to a hash is by throwing every possible combination of letters at it.  In simpler terms, the computer brute forces a password by guessing.  Each guess does not depend on the previous one.  The computer can guess 'password' and '12345678' as the password at the same time.  Generating strings does not demand a particular resource; they can be created on the fly without impacting the overall program data.
        </p>
        <p>Hayles defines the strengths of hyper attention as "negotiating rapidly changing environments in which multiple foci compete for attention."  This is also the case for parallel computing.  Each thread functions off of the same source and quickly reasons with the underlying architecture to solve a problem.  Hayles also indicates that hyper attention is instinctual in humans.  Survival demands quick reactions to a mutating environment.  Multi-threading fits this description as well.  Because each thread accesses the same program data, its environment can change rapidly.  The programmer must understand all of these parameters to effectively parallelize the program's functions.  In the threaded model example, the APU attends to each action at the same time.  Each distraction runs off the main attention line.  In order to manage this hyperactivity, you require hyper attention.
        </p>
        <p>Or do you?</p>
        <p>The forked APU model supports Hayles's deep attention concept.  "[C]oncentrating on a single object for long periods, ignoring outside stimuli while so engaged, preferring a single information stream, and having a high tolerance for long focus times" describe facets of a forking program's design.  Recall that a forked process has total control over its own set of program resources.  It accesses and modifies a unique copy of all program data.  In this sense, it is not subject to external influence.  The forked process remains in this state until it completes, and then it hands control back to the operating system.  The forked model treats the attention mechanism as something that directs deep attention.  In the forked model example, the APU attends to each action separately, not all three at once, as is the case with the threaded model.  While things may appear as distractions from a main task, they end up consuming your mental resources just the same, requiring deep attention.
        </p>
        <p style="font-family: Consolas,monospace; text-align: right; color:green;">end<span id="underscore">_</span></p>
        <br>
      </div>
    </div>

    <!-- Bootstrap core JavaScript -->
    <script src="vendor/jquery/jquery.min.js"></script>
    <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Custom scripts for this template -->
    <script src="js/grayscale.js"></script>
    <script src="js/pub_1.min.js"></script>

  </body>
</html>
